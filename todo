// replace hal functions to take i2c_t* instead of i2c_t, and so on for other periphs

// uart and usb cdc should also have function to open serial devices:
// uart_sdev_open(uart_t* uart)
// usb_cdc_sdev_open(...)

/*

SHOULD PASS ONLY PARAMS TO ALL FUNCTIONS WHICH ARE DEVICE SPECIFIC
STRUCT PARAMETERS WHICH ARE DEVICE INDEPENDENT SHOULD BE CHANGED THROUGH
FIXED FUNCTIONS

*/


src/drivers/i2c/stm32_hal_i2c.c

hal_status_t stm32_hal_i2c_write(i2c_t* i2c, ...)
{
    HAL_I2C_Master_Transmit((I2C_HandleTypeDef*)i2c->params, ...);
    ...
}

hal_status_t stm32_hal_i2c_open(i2c_t* i2c, I2C_HandleTypeDef* hal_hi2c)
{
    i2c->write = &stm32_hal_i2c_write;
    ...

    i2c->params = hal_hi2c;

    return HAL_STATUS_OK;
}

src/drivers/i2c_mux.c

hal_status_t i2c_mux_bus_write(i2c_t* i2c, uint8_t addr, uint8_t* data, size_t nbyte)
{
    i2c_mux_t* i2c_mux = (i2c_mux_t*)(i2c->params);

    if (!i2c_mux_sel_bus(i2c_mux))
        return HAL_STATUS_ERROR;
}

// replace order of mux and i2c so that it matches regular OOP order (instance (this) of the method comes first) in all open functions
i2c_mux_bus_open(i2c_t* i2c, i2c_mux_t* mux, i2c_mux_bus_e bus)
{

}

int i2c_mux_device_read(struct device* device, char* data, int len)
{
    i2c_mux_device_t* device = (i2c_mux_device_t*)(device->params);
    
    /* use i2c mux api to select the bus (does nothing if the bus is already selected) */
    i2c_mux_bus_select(device->mux, device->bus);

    /* use api to send the message */
    return i2c_mux_send(device->mux, device->addr, data, len);
}

instead of having i2c_mux_device_open could add:

typedef struct {
    i2c_mux_t* mux;
    i2c_mux_bus_e bus;
} i2c_mux_bus_t;

// handler for i2c_t.write
int i2c_mux_bus_write(i2c_t* i2c, uint8_t addr)

hal_status_t i2c_mux_bus_open(i2c_t* i2c, i2c_mux_t* mux, i2c_mux_bus_e bus)
{
    i2c->private_data = (i2c_mux_bus_t*)malloc(sizeof(i2c_mux_bus_t));

    if (!i2c->private_data)
        return HAL_STATUS_ERROR;

    i2c->private_data->mux = mux;
    i2c->private_data->bus = bus;

    i2c->write = &i2c_mux_bus_write;
    ...
}

which you can than use to open a device on this i2c mux bus


hal_status_t i2c_mux_device_open(struct device* device, i2c_mux_t* mux, enum i2c_mux_bus bus, uint8_t addr)
{
    /* device params can be pre allocated (statically) to avoid using malloc */
    if (device->params == NULL)
        /* check if malloc allowed, for ex: #ifdef HAL_MALLOC_ENABLED */
        device->params = malloc(sizeof(i2c_mux_device_t));

    device->params->mux = mux;
    device->params->bus = bus;
    device->params->addr = addr;

    device->read = &i2c_mux_device_read;
    // so on for write, ioctl, close...
}


each device type (pressure sensor, humidity sensor, i2c mux, led driver, ...) has an init (open) method which
takes struct device corresponding to that specific device and creates the api compatible struct for that type

example:

src/drivers/sensors/temperature/sensor_temperature.h

typedef struct sensor_temperature {
    struct device* device;
    hal_status_t (*get_temperature)(struct sensor_temperature* sensor, float16_t* temp);
} sensor_temperature_t;


src/drivers/sensors/temperature/bme280.c

hal_status_t bme280_sensor_temperature_open(sensor_temperature_t* sensor, struct device* device)
{
    sensor->device = device;
    sensor->get_temperature = &bme280_sensor_temperature_get;

    return HAL_STATUS_OK;
}

hal_status_t bme280_sensor_temperature_get(sensor_temperature_t* sensor, float16_t* temp)
{
    struct device* device = sensor->device;

    // select register to read
    int write_n = device->write(device, BME280_REG_TEMP, 1);

    if (write_n != 1)
        return HAL_STATUS_ERROR;

    // read register
    int read_n = device->read(device, temp, 2);

    // put next line into hal_core.h
    #define HAL_STATUS_ASSERT(x)    ((x) ? HAL_STATUS_OK : HAL_STATUS_ERROR)

    return HAL_STATUS_ASSERT(read_n == 2);
}

common/util/bitpack.h

typedef struct bitpack {
    uint8_t* data;
    size_t len;
} bitpack_t;

static inline bool bitpack_get(bitpack_t* bp, size_t pos)
{
    div_t d = div(pos, 8);
    return bp->data[d.quot] & (1 << d.rem);
}

static inline void bitpack_set(bitpack_t* bp, size_t pos)
{
    div_t d = div(pos, 8);
    bp->data[d.quot] |= (1 << d.rem);
}

same for clear...

src/i2c.c

/**
 * Bit j of byte i signals if device with the address 8*i+j is available
 *
 * detected 16 bytes of memory
 */
hal_status_t i2c_detect_devices(i2c_t* i2c, uint8_t* detected)
{
    for (uint8_t i = 0; i < 128; i++) {
        uint8_t bit = i2c->check_device(i2c = i2c, addr = i, data = NULL, len = 0) << (i >> 3);
        detected 
    }
}